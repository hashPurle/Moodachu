# Moodachu Smart Contract Documentation

This document provides essential information for understanding, compiling, deploying, and interacting with the Moodachu smart contract on the Midnight Network.

## 1. Contract Overview

The `Moodachu` smart contract is the on-chain component for the zero-knowledge emotional mediator project. It securely updates a shared virtual pet's mood (`pet_state`) based on aggregated emotional states from a couple, without ever revealing the private emotions themselves. This privacy is guaranteed through Groth16 Zero-Knowledge Proofs.

**Key Features:**
-   **ZK Proof Verification:** Verifies Groth16 proofs to ensure valid state transitions.
-   **State Management:** Stores and updates the `pet_state` (0-4) for each couple.
-   **Privacy-Preserving:** Only the aggregated `pet_state` is stored on-chain; raw emotions remain private.
-   **Event Emission:** Notifies off-chain services of pet state changes.

## 2. How to Compile the Contract

Currently, the `Moodachu` contract is written in Midnight's Compact language. The exact compilation process will depend on the official Midnight SDK and toolchain.

**Conceptual Compilation Steps:**

1.  **Install Midnight Compiler/SDK:** Ensure you have the Midnight development environment set up, which includes their Compact language compiler.
    ```bash
    # Example: This command is hypothetical
    midnight install-sdk
    ```
2.  **Navigate to Contract Directory:**
    ```bash
    cd contract/src
    ```
3.  **Compile the Contract:** Use the Midnight Compact compiler to generate bytecode and ABI artifacts.
    ```bash
    # Example: This command is hypothetical
    midnight compile moodachu_contract.midnight --output ../artifacts
    ```
    If you are using a Hardhat environment configured for Midnight (as suggested by the deployment script), the compilation might be integrated into Hardhat's workflow:
    ```bash
    cd contract/
    npx hardhat compile
    ```
    This command typically processes `.sol` files, but a Midnight Hardhat plugin would extend this to `.midnight` files, generating the necessary `Moodachu.json` ABI and bytecode in the `artifacts/` directory.

## 3. How to Deploy to Testnet

Deployment to the Midnight testnet requires configuring your Hardhat environment (or equivalent) to connect to the Midnight network and using a deployment script.

**Prerequisites:**
-   **Hardhat Setup:** Ensure your `contract/hardhat.config.cjs` is configured for the Midnight testnet. This involves adding a network entry with the correct RPC URL and chain ID, and providing an account's private key (securely via environment variables).
    ```javascript
    // Example hardhat.config.cjs snippet for Midnight testnet
    module.exports = {
      // ...
      networks: {
        midnightTestnet: {
          url: "https://rpc.testnet.midnight.network", // Replace with actual Midnight testnet RPC
          chainId: 12345, // Replace with actual Midnight testnet Chain ID
          accounts: [process.env.PRIVATE_KEY], // Securely load private key
        },
      },
      // ...
    };
    ```
-   **Testnet Tokens:** Fund the deployer account with sufficient testnet tokens to cover deployment costs.
-   **Verification Key:** Have your `verification_key.json` ready. You'll need to parse its components and pass them to the deployment script's `placeholderVerificationKey` object, ensuring the values match the `Groth16VerificationKey` struct in the contract.

**Deployment Steps:**

1.  **Update `deploy_moodachu.js`:** Open `contract/scripts/deploy_moodachu.js` and replace the placeholder values in `placeholderVerificationKey` with the actual field elements from your generated `verification_key.json`.
2.  **Run Deployment Script:** Execute the deployment script using Hardhat, specifying the Midnight testnet.
    ```bash
    cd contract/
    npx hardhat run scripts/deploy_moodachu.js --network midnightTestnet
    ```
3.  **Verify Output:** The script will output the deployed contract address and save it to `contract/deployed_address.json`. Check the console for any errors.

## 4. API Reference for Frontend Team

The Moodachu smart contract exposes the following public functions and events for interaction from the frontend.

### Functions

#### `submitProof(pairId: bytes32, claimedState: u8, proof: Groth16Proof) -> bool`
-   **Description:** Submits a zero-knowledge proof to update a couple's pet state. This is the primary function for users to interact with the contract.
-   **Parameters:**
    -   `pairId`: `bytes32` - A unique identifier for the couple (e.g., a hash of their wallet addresses).
    -   `claimedState`: `u8` (0-4) - The new pet state that the ZK proof asserts to be true.
    -   `proof`: `Groth16Proof` - The formatted Groth16 proof generated by the off-chain ZK circuit.
-   **Returns:** `bool` - `true` if the proof was successfully verified and the state updated. Reverts on invalid input or failed proof verification.
-   **Emits:** `PairCreated` (if new pair), `PetStateUpdated`.

#### `getPetState(pairId: bytes32) -> u8`
-   **Description:** A `view` function to retrieve the current pet state for a given couple.
-   **Parameters:**
    -   `pairId`: `bytes32` - The unique identifier for the couple.
-   **Returns:** `u8` (0-4) - The current pet state. Returns `0` (NEUTRAL) if the `pairId` does not exist.

#### `getPairInfo(pairId: bytes32) -> PairState`
-   **Description:** A `view` function to retrieve all stored information (`PairState` struct) for a given couple.
-   **Parameters:**
    -   `pairId`: `bytes32` - The unique identifier for the couple.
-   **Returns:** `PairState` - The complete `PairState` struct. Returns a default-initialized `PairState` if the `pairId` does not exist.

### Events

#### `PetStateUpdated(pairId: bytes32, newState: u8, timestamp: u64)`
-   **Description:** Emitted when a couple's pet state is successfully changed.
-   **Arguments:**
    -   `pairId`: `bytes32` - The unique identifier of the couple.
    -   `newState`: `u8` - The new pet state (0-4).
    -   `timestamp`: `u64` - The block timestamp when the update occurred.

#### `PairCreated(pairId: bytes32, timestamp: u64)`
-   **Description:** Emitted when a new couple's data is first recorded in the contract.
-   **Arguments:**
    -   `pairId`: `bytes32` - The unique identifier of the newly created couple.
    -   `timestamp`: `u64` - The block timestamp when the pair was created.

For frontend interaction examples using `ethers.js`, refer to `frontend/src/utils/moodachuContractHelpers.ts`.

## 5. Gas Optimization Notes

The primary gas cost of this contract will be dominated by the Groth16 proof verification. Midnight Network is designed to be ZK-friendly, so their native verifier primitive should be highly optimized.

**General Optimization Principles Applied/Considerations:**
-   **Minimize Storage Writes:** Writing to blockchain storage is expensive. The contract minimizes writes by only updating the `PairState` struct when necessary.
-   **Efficient Data Structures:** Using a `mapping` for `pair_states` provides efficient O(1) lookups.
-   **No Expensive Loops:** There are no arbitrary loops in the core logic that could lead to unbounded gas costs.
-   **ZK Verifier Intrinsic:** The `verify_groth16_proof` function is designed to call a native Midnight primitive. This is crucial for gas efficiency, as custom Solidity/Compact implementations of pairing checks would be prohibitively expensive.
-   **Input Validation:** Early input validation (e.g., `claimedState` range check) saves gas by reverting transactions before expensive operations if inputs are invalid.

**Future Considerations for further optimization (if needed):**
-   **Hydra/L2 Integration:** If high throughput is required, exploring Midnight's L2 solutions (like Hydra) for off-chain verification with batch commitments to L1 could significantly reduce on-chain gas costs per proof.
-   **Rate Limiting:** Implementing rate limits for `submitProof` could prevent spam and accidental high gas usage, though this adds some state overhead.

## 6. Verification Key Placeholder

The `verification_key` in the contract and deployment script is currently a placeholder. When you receive the actual `verification_key.json` from the ZK engineer, you will need to:

1.  **Parse `verification_key.json`:** Convert the hex string values from the JSON into the `FieldElement` (u256) format expected by your deployment script and the Compact contract.
2.  **Update `Groth16VerificationKey` Struct:** If the actual VK structure is more complex than the simplified one in `moodachu_contract.midnight`, you will need to update the `Groth16VerificationKey` struct in the contract.
3.  **Update Deployment Script:** Replace the `placeholderVerificationKey` object in `contract/scripts/deploy_moodachu.js` with the correctly parsed values from your actual `verification_key.json`.
4.  **Update Test Suite:** Similarly, update the `placeholderVerificationKey` in `contract/tests/moodachu.test.js` to reflect the real VK components for more accurate testing.
5.  **Update `ic_length`:** Ensure the `ic_length` field in the `Groth16VerificationKey` struct and the deployment script precisely matches the number of public inputs your ZK circuit is designed to handle.

By following these steps, you can seamlessly integrate the real verification key into your project.