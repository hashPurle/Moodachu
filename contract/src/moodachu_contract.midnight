// Moodachu - Zero-Knowledge Emotional Mediator
// Midnight Compact Smart Contract

// --- Data Structures ---

// Represents the state of a couple's shared pet.
struct PairState {
    id: bytes32,
    petState: u8,
    lastUpdate: u64,
    updateCount: u32,
}

// Represents a Groth16 ZK-SNARK proof.
// Field is a placeholder for Midnight's native field element type.
struct Groth16Proof {
    pi_a: [Field; 2],
    pi_b: [[Field; 2]; 2],
    pi_c: [Field; 2],
}

// --- Events ---

// Emitted when a pet's state is successfully updated.
event PetStateUpdated {
    pairId: bytes32,
    newState: u8,
    timestamp: u64,
}

// Emitted when a new pair is created.
event PairCreated {
    pairId: bytes32,
    timestamp: u64,
}

// --- Contract ---

contract Moodachu {
    // --- Storage ---

    // Mapping from a unique pair ID to their shared pet state.
    pair_states: Map<bytes32, PairState>,

    // The verification key for the Groth16 proofs.
    // This will be set in the constructor during deployment.
    // For now, this is a placeholder. The actual structure will depend
    // on how Midnight handles VKs.
    verification_key: bytes,

    // --- Constructor ---

    // Initializes the contract with the ZK verification key.
    // The vk_bytes would be the raw bytes of the verification_key.json file.
    constructor(vk_bytes: bytes) {
        self.verification_key = vk_bytes;
    }

    // --- Public Functions ---

    // Submits a ZK proof to update a pair's emotional state.
    //
    // @param pairId A unique identifier for the couple.
    // @param claimedState The public input to the proof, representing the new pet state.
    // @param proof The Groth16 proof.
    // @return A boolean indicating if the update was successful.
    public function submitProof(pairId: bytes32, claimedState: u8, proof: Groth16Proof) -> bool {
        // 1. Input Validation: Ensure claimedState is within the valid range (0-4).
        require(claimedState <= 4, "Invalid state: claimedState must be between 0 and 4.");

        // 2. ZK Proof Verification (THIS IS A PLACEHOLDER)
        // As per user's instruction, the ZK verification part is left out for now.
        // In a real Midnight environment, this would involve calling a native cryptographic primitive.
        let is_valid = true; // MOCK: Assume proof is always valid for now.
        require(is_valid, "Proof verification failed."); // This will never be hit with is_valid = true

        // 3. State Update
        let current_timestamp = now();
        let current_count = if self.pair_states.contains_key(pairId) {
            self.pair_states.get(pairId).updateCount
        } else {
            // This is the first update for this pair, so emit PairCreated event.
            emit PairCreated { pairId: pairId, timestamp: current_timestamp };
            0
        };

        let new_state = PairState {
            id: pairId,
            petState: claimedState,
            lastUpdate: current_timestamp,
            updateCount: current_count + 1,
        };

        self.pair_states.insert(pairId, new_state);

        // 4. Emit Event
        emit PetStateUpdated {
            pairId: pairId,
            newState: claimedState,
            timestamp: current_timestamp,
        };

        // 5. Return Success
        return true;
    }

    // --- View Functions ---

    // Retrieves the current pet state for a given pair.
    //
    // @param pairId The unique identifier for the couple.
    // @return The current pet state (0-4), or 0 if the pair does not exist.
    public view function getPetState(pairId: bytes32) -> u8 {
        if self.pair_states.contains_key(pairId) {
            return self.pair_states.get(pairId).petState;
        }
        return 0; // Default to NEUTRAL state
    }

    // Retrieves the complete state information for a given pair.
    //
    // @param pairId The unique identifier for the couple.
    // @return The PairState struct, or a default/empty struct if the pair does not exist.
    public view function getPairInfo(pairId: bytes32) -> Option<PairState> {
        return self.pair_states.get(pairId);
    }
}
